## Examples: Finding discrete logarithms in $\mathbb Z_p^*$

### Prerequisites
Launch [Sage](https://www.sagemath.org) and load the [<code>logarithm-finding.sage</code>](../logarithm-finding.sage) script by executing:
```console
$ sage
(..)
sage: load("logarithm-finding.sage")
```

### Simulating the quantum algorithm
To simulate solving the discrete logarithm in $\mathbb Z_p^*$ for $p$ an $n$-bit prime, first setup such a prime on special form, together with a generator $g$, by executing:

```console
sage: n = 2048
sage: [g, p] = sample_domain_parameters_safe_prime(n, verbose = True)
Sampling domain parameters...

 Sampled p = 29844161713265728814353357689425540844736599337304854249008513858846952744318378724111782435991628837225826463940922753659420264970826646842417665553452227176389877282669184025625695151033766134519809656426181854977016617469448022285117685384284687674090009158268616280656799169812886903521059467165388330612772587750187834642678012837781369733207392684278605270655860106981346729534754072299883648680677592377787304818225590996638776674369635890397060309738649734821660628648985476754427065351423006950986614124477120765429966138562633685198132619551099882768800325421543589040525631049204112900287661373090474258727
 Sampled g = 2

 Time required to sample: 1 sec 487 ms 359 µs
```

This yields $p$ and $g$ for a simulated safe-prime group $\langle g \rangle \subset \mathbb Z_p^*$.

To instead generate $p$ and $g$ for a simulated Schnorr group, with $g$ of order approximately $2^{112}$ and $n$ as above, execute:

```console
sage: [g, p] = sample_domain_parameters_schnorr(n, 112, verbose = True)
Sampling domain parameters...
 Sampled p = 19424564081488831845947067297113628035635514066507086484161113580280619311055663650195460298102142724792704352741811101164757653336720759309507091423565538812067570277028761435738092177513015999122061718679750171657925288591144155992216182191931167145643863424360506020995018306643963291714968234155426360585275923556679344865935956351051948113418857801877164783628716791237151077299168701246486384841974495787193552261079828441209831736666702875760218610261424495656011937550167873942323048439866240680164064359311911519277556244822106341780425877246704430812364856834694679318430066260396497608901569381971781197311
 Sampled g = 10417128955878057696290717221914965140092949762432707458764740994969053000525006333305667107648187738060507299694347216358853366841125794406048981295856152577464799939908989412008406937504663671741372248798311627753019095297561533498242814476053034565857631466385409857567606200528363186371944519518006507034961058093784156022468447708476658070374885093469118391020885932703038628022146938503548087307356084343806966072981319664750539403407104513174243068339898934178048256994706413085457705190227391149143742449628739982449910902564874659587876810594263352481042231462714594560807489149539707957175717053010818895265

 Time required to sample: 2 sec 901 ms 928 µs
```

Next, to generate a random problem instance $x = g^e$, execute:

```console
sage: [x, e] = sample_x(g, p)
```

Finally, generate a basis for the $d$-dimensional lattice for this problem instance, where $d = \lceil \sqrt{n} \rceil$, by executing:

```console
sage: d = ceil(sqrt(n))
sage: B = generate_basis_for_logarithm_finding(p, u = [x, g], d = d, verbose = True)
Generating a basis for the lattice L...
 Sampling vectors from L...
  Sampling vectors 1 to 8 of 54 using 8 threads...
  Sampling vectors 9 to 16 of 54 using 8 threads...
  Sampling vectors 17 to 24 of 54 using 8 threads...
  Sampling vectors 25 to 32 of 54 using 8 threads...
  Sampling vectors 33 to 40 of 54 using 8 threads...
  Sampling vectors 41 to 48 of 54 using 8 threads...
  Sampling vectors 49 to 54 of 54 using 8 threads...

 Reducing the basis for L, this may take a moment...

 Time required to generate a basis for L: 1 min 34 sec 250 ms 11 µs
```

This basis can then be used to setup the simulator by executing:

```console
sage: simulator = Simulator(B, verbose = True)
Setting up the simulator...
 Computing the basis for the dual L^* of L...
 Computing the Gram–Schmidt orthogonalization of the basis...

 Time required to setup the simulator: 7 sec 738 ms 528 µs
```

Finally, simulate running the quantum algorithm $d + 4$ times with $C = 2$ by executing:

```console
sage: C = 2
sage: R = get_regev_R(C, n)
sage: samples = simulator.sample_vectors(R, verbose = True)
Sampling 50 good vectors and 0 bad vectors...
 Sampling vectors 1 to 8 of 50 using 8 threads...
 Sampling vectors 9 to 16 of 50 using 8 threads...
 Sampling vectors 17 to 24 of 50 using 8 threads...
 Sampling vectors 25 to 32 of 50 using 8 threads...
 Sampling vectors 33 to 40 of 50 using 8 threads...
 Sampling vectors 41 to 48 of 50 using 8 threads...
 Sampling vectors 49 to 50 of 50 using 2 threads...

 Time required to sample: 4 sec 750 ms 240 µs
```

### Executing the classical post-processing
To solve the samples for the discrete logarithm $e$, execute:

```console
sage: e_found = solve_samples_for_logarithm(samples, g, x, p, R, verbose = True)
Post-processing the sampled vectors to find the logarithm...
 Building the post-processing matrix...
 Running LLL on the post-processing matrix...
  Found 46 / 46 linearly independent vectors...

 Found e = 129322941246806740263325590181402475
 Found r = 135301808177645793573445197462833413

 Time required to post-process: 12 sec 714 ms 636 µs
```

### Convenience test function
There are also convenience test functions that perform the above procedure for either Schnorr groups or safe-prime groups.

To try it out for a safe-prime group with $p$ of length $512$ bits, execute:

```console
sage: result = test_logarithm_finding_in_safe_prime_group(512, verbose = True)
** Setting up the problem instance...

Sampling domain parameters...

 Sampled p = 9322666400113347361491548797388939386568385763003935636323145773400049286742526910823700038836436719816724748650636564717430952825638247357742771641365643
 Sampled g = 3

 Time required to sample: 14 ms 85 µs

 Sampled e = 871328155825872014310131659353849814834357500172169470854571397846909846932071628291273130789901683457100780173088745937328061494852704128813909639822768
 Computed x = g^e mod p = 2136962357944850068109202204826198378392142050587743715278624921876959785568488303965961573896881358592493437370270376014446497142703319337395146105304531

** Setting up the simulator...

Generating a basis for the lattice L...
 Sampling vectors from L...
  Sampling vectors 1 to 8 of 31 using 8 threads...
  Sampling vectors 9 to 16 of 31 using 8 threads...
  Sampling vectors 17 to 24 of 31 using 8 threads...
  Sampling vectors 25 to 31 of 31 using 8 threads...

 Reducing the basis for L, this may take a moment...

 Time required to generate a basis for L: 930 ms 842 µs

Setting up the simulator...
 Computing the basis for the dual L^* of L...
 Computing the Gram–Schmidt orthogonalization of the basis...

 Time required to setup the simulator: 212 ms 244 µs

** Sampling vectors...

Sampling 27 good vectors and 0 bad vectors...
 Sampling vectors 1 to 8 of 27 using 8 threads...
 Sampling vectors 9 to 16 of 27 using 8 threads...
 Sampling vectors 17 to 24 of 27 using 8 threads...
 Sampling vectors 25 to 27 of 27 using 3 threads...

 Time required to sample: 189 ms 321 µs

** Solving for the logarithm...

Post-processing the sampled vectors to find the logarithm...
 Building the post-processing matrix...
 Running LLL on the post-processing matrix...
  Found 23 / 23 linearly independent vectors...

 Found e = 871328155825872014310131659353849814834357500172169470854571397846909846932071628291273130789901683457100780173088745937328061494852704128813909639822768
 Found r = 4661333200056673680745774398694469693284192881501967818161572886700024643371263455411850019418218359908362374325318282358715476412819123678871385820682821

 Time required to post-process: 329 ms 683 µs
sage: print(f"Found the expected discrete logarithm: {result}")
Found the expected discrete logarithm: True

```

To try it out for a Schnorr group of order approximately $2^{64}$ with $p$ of length $512$ bits, instead execute:

```console
sage: result = test_logarithm_finding_in_schnorr_group(512, 64, verbose = True)
** Setting up the problem instance...

Sampling domain parameters...
 Sampled p = 10890486155361340681247125140435922458342162381838386940991389152559483326841869961116023866825819650067765900377720534636639396399516158174750856362138279
 Sampled g = 5550138614074516676056280707396633648929735458968999591754334749800133575045550955910263247087177781678316828360299739015312660545842843556378564249239454

 Time required to sample: 11 ms 680 µs

 Sampled e = 38138973864120221794887
 Computed x = g^e mod p = 6885115438387192411091169926053845597935335397467755481192310581417775425716685435265391760014182138303316761725397597097968225606497157923209983738589293

** Setting up the simulator...

Generating a basis for the lattice L...
 Sampling vectors from L...
  Sampling vectors 1 to 8 of 31 using 8 threads...
  Sampling vectors 9 to 16 of 31 using 8 threads...
  Sampling vectors 17 to 24 of 31 using 8 threads...
  Sampling vectors 25 to 31 of 31 using 8 threads...

 Reducing the basis for L, this may take a moment...

 Time required to generate a basis for L: 1 sec 37 ms 155 µs

Setting up the simulator...
 Computing the basis for the dual L^* of L...
 Computing the Gram–Schmidt orthogonalization of the basis...

 Time required to setup the simulator: 203 ms 916 µs

** Sampling vectors...

Sampling 27 good vectors and 0 bad vectors...
 Sampling vectors 1 to 8 of 27 using 8 threads...
 Sampling vectors 9 to 16 of 27 using 8 threads...
 Sampling vectors 17 to 24 of 27 using 8 threads...
 Sampling vectors 25 to 27 of 27 using 3 threads...

 Time required to sample: 176 ms 606 µs

** Solving for the logarithm...

Post-processing the sampled vectors to find the logarithm...
 Building the post-processing matrix...
 Running LLL on the post-processing matrix...
  Found 23 / 23 linearly independent vectors...

 Found e = 38138973864120221794887
 Found r = 131829837629912578562009

 Time required to post-process: 331 ms 402 µs
sage: print(f"Found the expected discrete logarithm: {result}")
Found the expected discrete logarithm: True
```

Note that there are many optional parameters that can be passed to the above convenience functions, and to the functions they in turn call, allowing the simulation, sampling and post-processing to be tweaked in various ways. For further details, please see the source code documentation for the aforementioned functions.